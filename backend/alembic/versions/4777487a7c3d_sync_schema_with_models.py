"""sync_schema_with_models

Revision ID: 4777487a7c3d
Revises: 029_add_stock_reservations
Create Date: 2026-01-17 12:37:37.872804

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql
from sqlalchemy import inspect

# revision identifiers, used by Alembic.
revision: str = '4777487a7c3d'
down_revision: Union[str, None] = '029_add_stock_reservations'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def column_exists(table_name: str, column_name: str) -> bool:
    """Check if a column exists in a table."""
    bind = op.get_bind()
    inspector = inspect(bind)
    columns = [col['name'] for col in inspector.get_columns(table_name)]
    return column_name in columns


def index_exists(table_name: str, index_name: str) -> bool:
    """Check if an index exists on a table."""
    bind = op.get_bind()
    inspector = inspect(bind)
    indexes = [idx['name'] for idx in inspector.get_indexes(table_name)]
    return index_name in indexes


def table_exists(table_name: str) -> bool:
    """Check if a table exists."""
    bind = op.get_bind()
    inspector = inspect(bind)
    return table_name in inspector.get_table_names()


def constraint_exists(table_name: str, constraint_name: str) -> bool:
    """Check if a constraint exists on a table."""
    bind = op.get_bind()
    inspector = inspect(bind)
    # Check unique constraints
    unique_constraints = inspector.get_unique_constraints(table_name)
    if any(c['name'] == constraint_name for c in unique_constraints):
        return True
    # Check foreign key constraints
    fk_constraints = inspector.get_foreign_keys(table_name)
    if any(c['name'] == constraint_name for c in fk_constraints):
        return True
    return False


def unique_constraint_exists_on_columns(table_name: str, columns: list[str]) -> bool:
    bind = op.get_bind()
    inspector = inspect(bind)
    target = tuple(columns)
    for c in inspector.get_unique_constraints(table_name):
        col_names = tuple(c.get('column_names') or [])
        if col_names == target:
            return True
    return False


def foreign_key_exists(table_name: str, constrained_columns: list[str], referred_table: str, referred_columns: list[str]) -> bool:
    bind = op.get_bind()
    inspector = inspect(bind)
    target_cols = tuple(constrained_columns)
    target_referred_cols = tuple(referred_columns)
    for fk in inspector.get_foreign_keys(table_name):
        if (tuple(fk.get('constrained_columns') or []) == target_cols and
            fk.get('referred_table') == referred_table and
            tuple(fk.get('referred_columns') or []) == target_referred_cols):
            return True
    return False


def column_is_timestamptz(table_name: str, column_name: str) -> bool:
    bind = op.get_bind()
    inspector = inspect(bind)
    for col in inspector.get_columns(table_name):
        if col.get('name') == column_name:
            col_type = col.get('type')
            return isinstance(col_type, postgresql.TIMESTAMP) and bool(getattr(col_type, 'timezone', False))
    return False


def column_is_varchar(table_name: str, column_name: str) -> bool:
    bind = op.get_bind()
    inspector = inspect(bind)
    for col in inspector.get_columns(table_name):
        if col.get('name') == column_name:
            col_type = col.get('type')
            return isinstance(col_type, (sa.VARCHAR, sa.String))
    return False


def enum_type_exists(type_name: str) -> bool:
    bind = op.get_bind()
    exists = bind.execute(
        sa.text(
            """
            SELECT EXISTS (
              SELECT 1
              FROM pg_type t
              JOIN pg_namespace n ON n.oid = t.typnamespace
              WHERE t.typname = :type_name
            )
            """
        ),
        {"type_name": type_name},
    ).scalar()
    return bool(exists)


def ensure_enum_type(type_name: str, values: list[str]) -> None:
    if enum_type_exists(type_name):
        return
    quoted_values = ", ".join([f"'{v}'" for v in values])
    op.execute(sa.text(f"CREATE TYPE {type_name} AS ENUM ({quoted_values})"))


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    # Safely drop stock_reservations table and its indexes if they exist
    if table_exists('stock_reservations'):
        if index_exists('stock_reservations', 'idx_stock_reservations_layby'):
            op.drop_index(op.f('idx_stock_reservations_layby'), table_name='stock_reservations')
        if index_exists('stock_reservations', 'idx_stock_reservations_location'):
            op.drop_index(op.f('idx_stock_reservations_location'), table_name='stock_reservations')
        if index_exists('stock_reservations', 'idx_stock_reservations_product'):
            op.drop_index(op.f('idx_stock_reservations_product'), table_name='stock_reservations')
        if index_exists('stock_reservations', 'idx_stock_reservations_status'):
            op.drop_index(op.f('idx_stock_reservations_status'), table_name='stock_reservations')
        op.drop_table('stock_reservations')
    
    if index_exists('business_users', 'ix_business_users_department_id'):
        op.drop_index(op.f('ix_business_users_department_id'), table_name='business_users')
    
    if not column_exists('departments', 'deleted_at'):
        op.add_column('departments', sa.Column('deleted_at', sa.DateTime(timezone=True), nullable=True))
    
    # Departments - alter columns are safe to run multiple times (idempotent)
    op.alter_column('departments', 'created_at',
               existing_type=postgresql.TIMESTAMP(),
               type_=sa.DateTime(timezone=True),
               existing_nullable=False,
               existing_server_default=sa.text('now()'))
    op.alter_column('departments', 'updated_at',
               existing_type=postgresql.TIMESTAMP(),
               type_=sa.DateTime(timezone=True),
               existing_nullable=False,
               existing_server_default=sa.text('now()'))
    
    if index_exists('departments', 'ix_departments_business_id'):
        op.drop_index(op.f('ix_departments_business_id'), table_name='departments')
    if constraint_exists('departments', 'uq_departments_business_name'):
        op.drop_constraint(op.f('uq_departments_business_name'), 'departments', type_='unique')
    
    # Favorite products
    op.alter_column('favorite_products', 'auto_reorder',
               existing_type=sa.BOOLEAN(),
               nullable=True,
               existing_server_default=sa.text('false'))
    op.alter_column('favorite_products', 'sort_order',
               existing_type=sa.INTEGER(),
               nullable=True,
               existing_server_default=sa.text('0'))
    op.alter_column('favorite_products', 'created_at',
               existing_type=postgresql.TIMESTAMP(),
               type_=sa.DateTime(timezone=True),
               existing_nullable=False,
               existing_server_default=sa.text('now()'))
    op.alter_column('favorite_products', 'updated_at',
               existing_type=postgresql.TIMESTAMP(),
               type_=sa.DateTime(timezone=True),
               existing_nullable=False,
               existing_server_default=sa.text('now()'))
    op.alter_column('favorite_products', 'deleted_at',
               existing_type=postgresql.TIMESTAMP(),
               type_=sa.DateTime(timezone=True),
               existing_nullable=True)
    
    if index_exists('favorite_products', 'ix_favorite_products_unique'):
        op.drop_index(op.f('ix_favorite_products_unique'), table_name='favorite_products', postgresql_where='(deleted_at IS NULL)')
    if constraint_exists('favorite_products', 'favorite_products_product_id_fkey'):
        op.drop_constraint(op.f('favorite_products_product_id_fkey'), 'favorite_products', type_='foreignkey')
    if constraint_exists('favorite_products', 'favorite_products_business_id_fkey'):
        op.drop_constraint(op.f('favorite_products_business_id_fkey'), 'favorite_products', type_='foreignkey')
    if constraint_exists('favorite_products', 'favorite_products_user_id_fkey'):
        op.drop_constraint(op.f('favorite_products_user_id_fkey'), 'favorite_products', type_='foreignkey')
    
    if not foreign_key_exists('favorite_products', ['user_id'], 'users', ['id']):
        op.create_foreign_key(None, 'favorite_products', 'users', ['user_id'], ['id'])
    if not foreign_key_exists('favorite_products', ['business_id'], 'businesses', ['id']):
        op.create_foreign_key(None, 'favorite_products', 'businesses', ['business_id'], ['id'])
    if not foreign_key_exists('favorite_products', ['product_id'], 'products', ['id']):
        op.create_foreign_key(None, 'favorite_products', 'products', ['product_id'], ['id'])
    
    # Invoices
    if index_exists('invoices', 'ix_invoices_paystack_reference'):
        op.drop_index(op.f('ix_invoices_paystack_reference'), table_name='invoices')
    if not index_exists('invoices', 'ix_invoices_payment_reference'):
        op.create_index(op.f('ix_invoices_payment_reference'), 'invoices', ['payment_reference'], unique=False)
    if column_exists('invoices', 'paystack_access_code'):
        op.drop_column('invoices', 'paystack_access_code')
    if column_exists('invoices', 'gateway_fee'):
        op.drop_column('invoices', 'gateway_fee')
    if column_exists('invoices', 'paystack_reference'):
        op.drop_column('invoices', 'paystack_reference')
    if column_exists('invoices', 'gateway_fee_percent'):
        op.drop_column('invoices', 'gateway_fee_percent')
    
    # Job execution logs
    op.alter_column('job_execution_logs', 'invoices_processed',
               existing_type=sa.INTEGER(),
               nullable=False)
    op.alter_column('job_execution_logs', 'notifications_created',
               existing_type=sa.INTEGER(),
               nullable=False)
    op.alter_column('job_execution_logs', 'error_count',
               existing_type=sa.INTEGER(),
               nullable=False)
    op.alter_column('job_execution_logs', 'created_at',
               existing_type=postgresql.TIMESTAMP(),
               type_=sa.DateTime(timezone=True),
               existing_nullable=False)
    op.alter_column('job_execution_logs', 'updated_at',
               existing_type=postgresql.TIMESTAMP(),
               type_=sa.DateTime(timezone=True),
               existing_nullable=False)
    op.alter_column('job_execution_logs', 'deleted_at',
               existing_type=postgresql.TIMESTAMP(),
               type_=sa.DateTime(timezone=True),
               existing_nullable=True)
    
    # Layby audit
    if not column_exists('layby_audit', 'updated_at'):
        op.add_column('layby_audit', sa.Column('updated_at', sa.DateTime(timezone=True), nullable=False))
    if not column_exists('layby_audit', 'deleted_at'):
        op.add_column('layby_audit', sa.Column('deleted_at', sa.DateTime(timezone=True), nullable=True))
    if index_exists('layby_audit', 'idx_layby_audit_created'):
        op.drop_index(op.f('idx_layby_audit_created'), table_name='layby_audit')
    if index_exists('layby_audit', 'idx_layby_audit_layby'):
        op.drop_index(op.f('idx_layby_audit_layby'), table_name='layby_audit')
    if not index_exists('layby_audit', 'ix_layby_audit_layby_id'):
        op.create_index(op.f('ix_layby_audit_layby_id'), 'layby_audit', ['layby_id'], unique=False)
    
    # Layby config
    if not column_exists('layby_config', 'deleted_at'):
        op.add_column('layby_config', sa.Column('deleted_at', sa.DateTime(timezone=True), nullable=True))
    
    # Layby items
    if not column_exists('layby_items', 'updated_at'):
        op.add_column('layby_items', sa.Column('updated_at', sa.DateTime(timezone=True), nullable=False))
    if not column_exists('layby_items', 'deleted_at'):
        op.add_column('layby_items', sa.Column('deleted_at', sa.DateTime(timezone=True), nullable=True))
    
    # Layby notifications
    if not column_exists('layby_notifications', 'updated_at'):
        op.add_column('layby_notifications', sa.Column('updated_at', sa.DateTime(timezone=True), nullable=False))
    if not column_exists('layby_notifications', 'deleted_at'):
        op.add_column('layby_notifications', sa.Column('deleted_at', sa.DateTime(timezone=True), nullable=True))

    # Ensure enum types exist before attempting to alter columns to those enums.
    # Postgres requires the enum type to exist, otherwise ALTER COLUMN ... TYPE fails.
    ensure_enum_type('notificationchannel', ['email', 'sms', 'push', 'in_app'])
    ensure_enum_type('notificationstatus', ['pending', 'sent', 'failed', 'cancelled'])
    ensure_enum_type('laybypaymenttype', ['deposit', 'installment', 'final', 'overpayment'])
    ensure_enum_type('laybypaymentstatus', ['pending', 'completed', 'failed', 'refunded'])
    ensure_enum_type('schedulestatus', ['pending', 'partial', 'paid', 'overdue'])
    ensure_enum_type('laybystatus', ['draft', 'active', 'ready_for_collection', 'completed', 'cancelled', 'overdue'])
    ensure_enum_type('paymentfrequency', ['weekly', 'bi_weekly', 'monthly'])

    # Only run type conversions when the column is actually still VARCHAR / timestamptz.
    # Avoiding failed DDL is critical because Postgres aborts the whole transaction on the first failure.
    # Use raw SQL with USING clause for VARCHAR->ENUM conversions (Postgres requires explicit cast).
    # Must drop DEFAULT before type change, then re-add it with proper ENUM cast.
    if column_is_varchar('layby_notifications', 'channel'):
        op.execute(sa.text("ALTER TABLE layby_notifications ALTER COLUMN channel TYPE notificationchannel USING channel::notificationchannel"))
    if column_is_varchar('layby_notifications', 'status'):
        op.execute(sa.text("ALTER TABLE layby_notifications ALTER COLUMN status DROP DEFAULT"))
        op.execute(sa.text("ALTER TABLE layby_notifications ALTER COLUMN status TYPE notificationstatus USING status::notificationstatus"))
        op.execute(sa.text("ALTER TABLE layby_notifications ALTER COLUMN status SET DEFAULT 'pending'"))
    if column_is_timestamptz('layby_notifications', 'sent_at'):
        op.alter_column('layby_notifications', 'sent_at',
                   existing_type=postgresql.TIMESTAMP(timezone=True),
                   type_=sa.DateTime(),
                   existing_nullable=True)
    
    if index_exists('layby_notifications', 'idx_layby_notifications_created'):
        op.drop_index(op.f('idx_layby_notifications_created'), table_name='layby_notifications')
    if index_exists('layby_notifications', 'idx_layby_notifications_layby'):
        op.drop_index(op.f('idx_layby_notifications_layby'), table_name='layby_notifications')
    if index_exists('layby_notifications', 'idx_layby_notifications_status'):
        op.drop_index(op.f('idx_layby_notifications_status'), table_name='layby_notifications')
    if index_exists('layby_notifications', 'idx_layby_notifications_type'):
        op.drop_index(op.f('idx_layby_notifications_type'), table_name='layby_notifications')
    if not index_exists('layby_notifications', 'ix_layby_notifications_layby_id'):
        op.create_index(op.f('ix_layby_notifications_layby_id'), 'layby_notifications', ['layby_id'], unique=False)
    if not index_exists('layby_notifications', 'ix_layby_notifications_notification_type'):
        op.create_index(op.f('ix_layby_notifications_notification_type'), 'layby_notifications', ['notification_type'], unique=False)
    if not index_exists('layby_notifications', 'ix_layby_notifications_status'):
        op.create_index(op.f('ix_layby_notifications_status'), 'layby_notifications', ['status'], unique=False)
    
    # Layby payments - use raw SQL with USING clause (drop/restore defaults)
    if column_is_varchar('layby_payments', 'payment_type'):
        op.execute(sa.text("ALTER TABLE layby_payments ALTER COLUMN payment_type TYPE laybypaymenttype USING payment_type::laybypaymenttype"))
    if column_is_varchar('layby_payments', 'status'):
        op.execute(sa.text("ALTER TABLE layby_payments ALTER COLUMN status DROP DEFAULT"))
        op.execute(sa.text("ALTER TABLE layby_payments ALTER COLUMN status TYPE laybypaymentstatus USING status::laybypaymentstatus"))
        op.execute(sa.text("ALTER TABLE layby_payments ALTER COLUMN status SET DEFAULT 'completed'"))
    
    if index_exists('layby_payments', 'idx_layby_payments_layby'):
        op.drop_index(op.f('idx_layby_payments_layby'), table_name='layby_payments')
    if not index_exists('layby_payments', 'ix_layby_payments_layby_id'):
        op.create_index(op.f('ix_layby_payments_layby_id'), 'layby_payments', ['layby_id'], unique=False)
    
    # Layby schedules - use raw SQL with USING clause (drop/restore defaults)
    if column_is_varchar('layby_schedules', 'status'):
        op.execute(sa.text("ALTER TABLE layby_schedules ALTER COLUMN status DROP DEFAULT"))
        op.execute(sa.text("ALTER TABLE layby_schedules ALTER COLUMN status TYPE schedulestatus USING status::schedulestatus"))
        op.execute(sa.text("ALTER TABLE layby_schedules ALTER COLUMN status SET DEFAULT 'pending'"))
    
    if index_exists('layby_schedules', 'idx_layby_schedules_due'):
        op.drop_index(op.f('idx_layby_schedules_due'), table_name='layby_schedules')
    if index_exists('layby_schedules', 'idx_layby_schedules_layby'):
        op.drop_index(op.f('idx_layby_schedules_layby'), table_name='layby_schedules')
    if not index_exists('layby_schedules', 'ix_layby_schedules_due_date'):
        op.create_index(op.f('ix_layby_schedules_due_date'), 'layby_schedules', ['due_date'], unique=False)
    if not index_exists('layby_schedules', 'ix_layby_schedules_layby_id'):
        op.create_index(op.f('ix_layby_schedules_layby_id'), 'layby_schedules', ['layby_id'], unique=False)
    
    # Laybys - use raw SQL with USING clause (drop/restore defaults)
    if not column_exists('laybys', 'deleted_at'):
        op.add_column('laybys', sa.Column('deleted_at', sa.DateTime(timezone=True), nullable=True))
    if column_is_varchar('laybys', 'status'):
        op.execute(sa.text("ALTER TABLE laybys ALTER COLUMN status DROP DEFAULT"))
        op.execute(sa.text("ALTER TABLE laybys ALTER COLUMN status TYPE laybystatus USING status::laybystatus"))
        op.execute(sa.text("ALTER TABLE laybys ALTER COLUMN status SET DEFAULT 'active'"))
    if column_is_varchar('laybys', 'payment_frequency'):
        op.execute(sa.text("ALTER TABLE laybys ALTER COLUMN payment_frequency TYPE paymentfrequency USING payment_frequency::paymentfrequency"))
    
    if index_exists('laybys', 'ix_laybys_business_customer'):
        op.drop_index(op.f('ix_laybys_business_customer'), table_name='laybys')
    if index_exists('laybys', 'ix_laybys_business_status'):
        op.drop_index(op.f('ix_laybys_business_status'), table_name='laybys')
    if index_exists('laybys', 'ix_laybys_next_payment_date'):
        op.drop_index(op.f('ix_laybys_next_payment_date'), table_name='laybys')
    if constraint_exists('laybys', 'laybys_reference_number_key'):
        op.drop_constraint(op.f('laybys_reference_number_key'), 'laybys', type_='unique')
    if index_exists('laybys', 'ix_laybys_reference_number'):
        op.drop_index(op.f('ix_laybys_reference_number'), table_name='laybys')
    if not index_exists('laybys', 'ix_laybys_reference_number'):
        op.create_index(op.f('ix_laybys_reference_number'), 'laybys', ['reference_number'], unique=True)
    
    # Notifications
    op.alter_column('notifications', 'is_read',
               existing_type=sa.BOOLEAN(),
               nullable=True,
               existing_server_default=sa.text('false'))
    op.alter_column('notifications', 'is_archived',
               existing_type=sa.BOOLEAN(),
               nullable=True,
               existing_server_default=sa.text('false'))
    op.alter_column('notifications', 'created_at',
               existing_type=postgresql.TIMESTAMP(),
               type_=sa.DateTime(timezone=True),
               existing_nullable=False,
               existing_server_default=sa.text('now()'))
    op.alter_column('notifications', 'updated_at',
               existing_type=postgresql.TIMESTAMP(),
               type_=sa.DateTime(timezone=True),
               existing_nullable=False,
               existing_server_default=sa.text('now()'))
    op.alter_column('notifications', 'deleted_at',
               existing_type=postgresql.TIMESTAMP(),
               type_=sa.DateTime(timezone=True),
               existing_nullable=True)
    
    if index_exists('notifications', 'ix_notifications_created_at'):
        op.drop_index(op.f('ix_notifications_created_at'), table_name='notifications')
    if constraint_exists('notifications', 'notifications_user_id_fkey'):
        op.drop_constraint(op.f('notifications_user_id_fkey'), 'notifications', type_='foreignkey')
    if constraint_exists('notifications', 'notifications_business_id_fkey'):
        op.drop_constraint(op.f('notifications_business_id_fkey'), 'notifications', type_='foreignkey')
    try:
        op.create_foreign_key(None, 'notifications', 'businesses', ['business_id'], ['id'])
    except Exception:
        pass
    try:
        op.create_foreign_key(None, 'notifications', 'users', ['user_id'], ['id'])
    except Exception:
        pass
    
    # POS connections
    op.alter_column('pos_connections', 'created_at',
               existing_type=postgresql.TIMESTAMP(),
               type_=sa.DateTime(timezone=True),
               nullable=False)
    op.alter_column('pos_connections', 'updated_at',
               existing_type=postgresql.TIMESTAMP(),
               type_=sa.DateTime(timezone=True),
               nullable=False)
    op.alter_column('pos_connections', 'deleted_at',
               existing_type=postgresql.TIMESTAMP(),
               type_=sa.DateTime(timezone=True),
               existing_nullable=True)
    
    if index_exists('pos_connections', 'ix_pos_connections_provider'):
        op.drop_index(op.f('ix_pos_connections_provider'), table_name='pos_connections')
    
    # POS sync logs
    op.alter_column('pos_sync_logs', 'created_at',
               existing_type=postgresql.TIMESTAMP(),
               type_=sa.DateTime(timezone=True),
               nullable=False)
    op.alter_column('pos_sync_logs', 'updated_at',
               existing_type=postgresql.TIMESTAMP(),
               type_=sa.DateTime(timezone=True),
               nullable=False)
    op.alter_column('pos_sync_logs', 'deleted_at',
               existing_type=postgresql.TIMESTAMP(),
               type_=sa.DateTime(timezone=True),
               existing_nullable=True)
    
    # Product suppliers
    op.alter_column('product_suppliers', 'created_at',
               existing_type=postgresql.TIMESTAMP(),
               type_=sa.DateTime(timezone=True),
               existing_nullable=False)
    op.alter_column('product_suppliers', 'updated_at',
               existing_type=postgresql.TIMESTAMP(),
               type_=sa.DateTime(timezone=True),
               existing_nullable=False)
    op.alter_column('product_suppliers', 'deleted_at',
               existing_type=postgresql.TIMESTAMP(),
               type_=sa.DateTime(timezone=True),
               existing_nullable=True)
    
    # Production orders
    op.alter_column('production_orders', 'status',
               existing_type=postgresql.ENUM('draft', 'pending', 'in_progress', 'completed', 'cancelled', name='productionstatus'),
               nullable=True,
               existing_server_default=sa.text("'draft'::productionstatus"))
    op.alter_column('production_orders', 'scheduled_date',
               existing_type=postgresql.TIMESTAMP(timezone=True),
               type_=sa.DateTime(),
               existing_nullable=True)
    op.alter_column('production_orders', 'started_at',
               existing_type=postgresql.TIMESTAMP(timezone=True),
               type_=sa.DateTime(),
               existing_nullable=True)
    op.alter_column('production_orders', 'completed_at',
               existing_type=postgresql.TIMESTAMP(timezone=True),
               type_=sa.DateTime(),
               existing_nullable=True)
    op.alter_column('production_orders', 'estimated_cost',
               existing_type=sa.NUMERIC(precision=12, scale=2),
               nullable=True,
               existing_server_default=sa.text("'0'::numeric"))
    op.alter_column('production_orders', 'actual_cost',
               existing_type=sa.NUMERIC(precision=12, scale=2),
               nullable=True,
               existing_server_default=sa.text("'0'::numeric"))
    
    if index_exists('production_orders', 'ix_production_orders_status'):
        op.drop_index(op.f('ix_production_orders_status'), table_name='production_orders')
    
    # Sessions
    if index_exists('sessions', 'ix_sessions_refresh_token_hash'):
        op.drop_index(op.f('ix_sessions_refresh_token_hash'), table_name='sessions')
    if not unique_constraint_exists_on_columns('sessions', ['refresh_token_hash']):
        op.create_unique_constraint(None, 'sessions', ['refresh_token_hash'])
    
    # Time entries
    op.alter_column('time_entries', 'created_at',
               existing_type=postgresql.TIMESTAMP(),
               type_=sa.DateTime(timezone=True),
               nullable=False)
    op.alter_column('time_entries', 'updated_at',
               existing_type=postgresql.TIMESTAMP(),
               type_=sa.DateTime(timezone=True),
               nullable=False)
    op.alter_column('time_entries', 'deleted_at',
               existing_type=postgresql.TIMESTAMP(),
               type_=sa.DateTime(timezone=True),
               existing_nullable=True)
    
    if index_exists('time_entries', 'ix_time_entries_clock_in'):
        op.drop_index(op.f('ix_time_entries_clock_in'), table_name='time_entries')
    
    # Users
    op.alter_column('users', 'biometric_public_key',
               existing_type=sa.TEXT(),
               type_=sa.String(),
               existing_nullable=True)
    
    if index_exists('users', 'ux_users_single_superadmin_true'):
        op.drop_index(op.f('ux_users_single_superadmin_true'), table_name='users', postgresql_where='(is_superadmin = true)')
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_index(op.f('ux_users_single_superadmin_true'), 'users', ['is_superadmin'], unique=True, postgresql_where='(is_superadmin = true)')
    op.alter_column('users', 'biometric_public_key',
               existing_type=sa.String(),
               type_=sa.TEXT(),
               existing_nullable=True)
    op.create_index(op.f('ix_time_entries_clock_in'), 'time_entries', ['clock_in'], unique=False)
    op.alter_column('time_entries', 'deleted_at',
               existing_type=sa.DateTime(timezone=True),
               type_=postgresql.TIMESTAMP(),
               existing_nullable=True)
    op.alter_column('time_entries', 'updated_at',
               existing_type=sa.DateTime(timezone=True),
               type_=postgresql.TIMESTAMP(),
               nullable=True)
    op.alter_column('time_entries', 'created_at',
               existing_type=sa.DateTime(timezone=True),
               type_=postgresql.TIMESTAMP(),
               nullable=True)
    op.drop_constraint(None, 'sessions', type_='unique')
    op.create_index(op.f('ix_sessions_refresh_token_hash'), 'sessions', ['refresh_token_hash'], unique=True)
    op.create_index(op.f('ix_production_orders_status'), 'production_orders', ['status'], unique=False)
    op.alter_column('production_orders', 'actual_cost',
               existing_type=sa.NUMERIC(precision=12, scale=2),
               nullable=False,
               existing_server_default=sa.text("'0'::numeric"))
    op.alter_column('production_orders', 'estimated_cost',
               existing_type=sa.NUMERIC(precision=12, scale=2),
               nullable=False,
               existing_server_default=sa.text("'0'::numeric"))
    op.alter_column('production_orders', 'completed_at',
               existing_type=sa.DateTime(),
               type_=postgresql.TIMESTAMP(timezone=True),
               existing_nullable=True)
    op.alter_column('production_orders', 'started_at',
               existing_type=sa.DateTime(),
               type_=postgresql.TIMESTAMP(timezone=True),
               existing_nullable=True)
    op.alter_column('production_orders', 'scheduled_date',
               existing_type=sa.DateTime(),
               type_=postgresql.TIMESTAMP(timezone=True),
               existing_nullable=True)
    op.alter_column('production_orders', 'status',
               existing_type=postgresql.ENUM('draft', 'pending', 'in_progress', 'completed', 'cancelled', name='productionstatus'),
               nullable=False,
               existing_server_default=sa.text("'draft'::productionstatus"))
    op.alter_column('product_suppliers', 'deleted_at',
               existing_type=sa.DateTime(timezone=True),
               type_=postgresql.TIMESTAMP(),
               existing_nullable=True)
    op.alter_column('product_suppliers', 'updated_at',
               existing_type=sa.DateTime(timezone=True),
               type_=postgresql.TIMESTAMP(),
               existing_nullable=False)
    op.alter_column('product_suppliers', 'created_at',
               existing_type=sa.DateTime(timezone=True),
               type_=postgresql.TIMESTAMP(),
               existing_nullable=False)
    op.alter_column('pos_sync_logs', 'deleted_at',
               existing_type=sa.DateTime(timezone=True),
               type_=postgresql.TIMESTAMP(),
               existing_nullable=True)
    op.alter_column('pos_sync_logs', 'updated_at',
               existing_type=sa.DateTime(timezone=True),
               type_=postgresql.TIMESTAMP(),
               nullable=True)
    op.alter_column('pos_sync_logs', 'created_at',
               existing_type=sa.DateTime(timezone=True),
               type_=postgresql.TIMESTAMP(),
               nullable=True)
    op.create_index(op.f('ix_pos_connections_provider'), 'pos_connections', ['provider'], unique=False)
    op.alter_column('pos_connections', 'deleted_at',
               existing_type=sa.DateTime(timezone=True),
               type_=postgresql.TIMESTAMP(),
               existing_nullable=True)
    op.alter_column('pos_connections', 'updated_at',
               existing_type=sa.DateTime(timezone=True),
               type_=postgresql.TIMESTAMP(),
               nullable=True)
    op.alter_column('pos_connections', 'created_at',
               existing_type=sa.DateTime(timezone=True),
               type_=postgresql.TIMESTAMP(),
               nullable=True)
    op.drop_constraint(None, 'notifications', type_='foreignkey')
    op.drop_constraint(None, 'notifications', type_='foreignkey')
    op.create_foreign_key(op.f('notifications_business_id_fkey'), 'notifications', 'businesses', ['business_id'], ['id'], ondelete='CASCADE')
    op.create_foreign_key(op.f('notifications_user_id_fkey'), 'notifications', 'users', ['user_id'], ['id'], ondelete='CASCADE')
    op.create_index(op.f('ix_notifications_created_at'), 'notifications', ['created_at'], unique=False)
    op.alter_column('notifications', 'deleted_at',
               existing_type=sa.DateTime(timezone=True),
               type_=postgresql.TIMESTAMP(),
               existing_nullable=True)
    op.alter_column('notifications', 'updated_at',
               existing_type=sa.DateTime(timezone=True),
               type_=postgresql.TIMESTAMP(),
               existing_nullable=False,
               existing_server_default=sa.text('now()'))
    op.alter_column('notifications', 'created_at',
               existing_type=sa.DateTime(timezone=True),
               type_=postgresql.TIMESTAMP(),
               existing_nullable=False,
               existing_server_default=sa.text('now()'))
    op.alter_column('notifications', 'is_archived',
               existing_type=sa.BOOLEAN(),
               nullable=False,
               existing_server_default=sa.text('false'))
    op.alter_column('notifications', 'is_read',
               existing_type=sa.BOOLEAN(),
               nullable=False,
               existing_server_default=sa.text('false'))
    op.drop_index(op.f('ix_laybys_reference_number'), table_name='laybys')
    op.create_index(op.f('ix_laybys_reference_number'), 'laybys', ['reference_number'], unique=False)
    op.create_unique_constraint(op.f('laybys_reference_number_key'), 'laybys', ['reference_number'], postgresql_nulls_not_distinct=False)
    op.create_index(op.f('ix_laybys_next_payment_date'), 'laybys', ['next_payment_date'], unique=False)
    op.create_index(op.f('ix_laybys_business_status'), 'laybys', ['business_id', 'status'], unique=False)
    op.create_index(op.f('ix_laybys_business_customer'), 'laybys', ['business_id', 'customer_id'], unique=False)
    op.alter_column('laybys', 'payment_frequency',
               existing_type=sa.Enum('weekly', 'bi_weekly', 'monthly', name='paymentfrequency'),
               type_=sa.VARCHAR(length=20),
               existing_nullable=False)
    op.alter_column('laybys', 'status',
               existing_type=sa.Enum('draft', 'active', 'ready_for_collection', 'completed', 'cancelled', 'overdue', name='laybystatus'),
               type_=sa.VARCHAR(length=20),
               existing_nullable=False,
               existing_server_default=sa.text("'active'::character varying"))
    op.drop_column('laybys', 'deleted_at')
    op.drop_index(op.f('ix_layby_schedules_layby_id'), table_name='layby_schedules')
    op.drop_index(op.f('ix_layby_schedules_due_date'), table_name='layby_schedules')
    op.create_index(op.f('idx_layby_schedules_layby'), 'layby_schedules', ['layby_id'], unique=False)
    op.create_index(op.f('idx_layby_schedules_due'), 'layby_schedules', ['due_date'], unique=False)
    op.alter_column('layby_schedules', 'status',
               existing_type=sa.Enum('pending', 'partial', 'paid', 'overdue', name='schedulestatus'),
               type_=sa.VARCHAR(length=20),
               existing_nullable=False,
               existing_server_default=sa.text("'pending'::character varying"))
    op.drop_index(op.f('ix_layby_payments_layby_id'), table_name='layby_payments')
    op.create_index(op.f('idx_layby_payments_layby'), 'layby_payments', ['layby_id'], unique=False)
    op.alter_column('layby_payments', 'status',
               existing_type=sa.Enum('pending', 'completed', 'failed', 'refunded', name='laybypaymentstatus'),
               type_=sa.VARCHAR(length=20),
               existing_nullable=False,
               existing_server_default=sa.text("'completed'::character varying"))
    op.alter_column('layby_payments', 'payment_type',
               existing_type=sa.Enum('deposit', 'installment', 'final', 'overpayment', name='laybypaymenttype'),
               type_=sa.VARCHAR(length=20),
               existing_nullable=False)
    op.drop_index(op.f('ix_layby_notifications_status'), table_name='layby_notifications')
    op.drop_index(op.f('ix_layby_notifications_notification_type'), table_name='layby_notifications')
    op.drop_index(op.f('ix_layby_notifications_layby_id'), table_name='layby_notifications')
    op.create_index(op.f('idx_layby_notifications_type'), 'layby_notifications', ['notification_type'], unique=False)
    op.create_index(op.f('idx_layby_notifications_status'), 'layby_notifications', ['status'], unique=False)
    op.create_index(op.f('idx_layby_notifications_layby'), 'layby_notifications', ['layby_id'], unique=False)
    op.create_index(op.f('idx_layby_notifications_created'), 'layby_notifications', ['created_at'], unique=False)
    op.alter_column('layby_notifications', 'sent_at',
               existing_type=sa.DateTime(),
               type_=postgresql.TIMESTAMP(timezone=True),
               existing_nullable=True)
    op.alter_column('layby_notifications', 'status',
               existing_type=sa.Enum('pending', 'sent', 'failed', 'cancelled', name='notificationstatus'),
               type_=sa.VARCHAR(length=20),
               existing_nullable=False,
               existing_server_default=sa.text("'pending'::character varying"))
    op.alter_column('layby_notifications', 'channel',
               existing_type=sa.Enum('email', 'sms', 'push', 'in_app', name='notificationchannel'),
               type_=sa.VARCHAR(length=20),
               existing_nullable=False)
    op.drop_column('layby_notifications', 'deleted_at')
    op.drop_column('layby_notifications', 'updated_at')
    op.drop_column('layby_items', 'deleted_at')
    op.drop_column('layby_items', 'updated_at')
    op.drop_column('layby_config', 'deleted_at')
    op.drop_index(op.f('ix_layby_audit_layby_id'), table_name='layby_audit')
    op.create_index(op.f('idx_layby_audit_layby'), 'layby_audit', ['layby_id'], unique=False)
    op.create_index(op.f('idx_layby_audit_created'), 'layby_audit', ['created_at'], unique=False)
    op.drop_column('layby_audit', 'deleted_at')
    op.drop_column('layby_audit', 'updated_at')
    op.alter_column('job_execution_logs', 'deleted_at',
               existing_type=sa.DateTime(timezone=True),
               type_=postgresql.TIMESTAMP(),
               existing_nullable=True)
    op.alter_column('job_execution_logs', 'updated_at',
               existing_type=sa.DateTime(timezone=True),
               type_=postgresql.TIMESTAMP(),
               existing_nullable=False)
    op.alter_column('job_execution_logs', 'created_at',
               existing_type=sa.DateTime(timezone=True),
               type_=postgresql.TIMESTAMP(),
               existing_nullable=False)
    op.alter_column('job_execution_logs', 'error_count',
               existing_type=sa.INTEGER(),
               nullable=True)
    op.alter_column('job_execution_logs', 'notifications_created',
               existing_type=sa.INTEGER(),
               nullable=True)
    op.alter_column('job_execution_logs', 'invoices_processed',
               existing_type=sa.INTEGER(),
               nullable=True)
    op.add_column('invoices', sa.Column('gateway_fee_percent', sa.NUMERIC(precision=5, scale=2), server_default=sa.text('1.5'), autoincrement=False, nullable=True))
    op.add_column('invoices', sa.Column('paystack_reference', sa.VARCHAR(length=100), autoincrement=False, nullable=True))
    op.add_column('invoices', sa.Column('gateway_fee', sa.NUMERIC(precision=12, scale=2), server_default=sa.text("'0'::numeric"), autoincrement=False, nullable=True))
    op.add_column('invoices', sa.Column('paystack_access_code', sa.VARCHAR(length=100), autoincrement=False, nullable=True))
    op.drop_index(op.f('ix_invoices_payment_reference'), table_name='invoices')
    op.create_index(op.f('ix_invoices_paystack_reference'), 'invoices', ['paystack_reference'], unique=False)
    op.drop_constraint(None, 'favorite_products', type_='foreignkey')
    op.drop_constraint(None, 'favorite_products', type_='foreignkey')
    op.drop_constraint(None, 'favorite_products', type_='foreignkey')
    op.create_foreign_key(op.f('favorite_products_user_id_fkey'), 'favorite_products', 'users', ['user_id'], ['id'], ondelete='CASCADE')
    op.create_foreign_key(op.f('favorite_products_business_id_fkey'), 'favorite_products', 'businesses', ['business_id'], ['id'], ondelete='CASCADE')
    op.create_foreign_key(op.f('favorite_products_product_id_fkey'), 'favorite_products', 'products', ['product_id'], ['id'], ondelete='CASCADE')
    op.create_index(op.f('ix_favorite_products_unique'), 'favorite_products', ['business_id', 'product_id', 'user_id'], unique=True, postgresql_where='(deleted_at IS NULL)')
    op.alter_column('favorite_products', 'deleted_at',
               existing_type=sa.DateTime(timezone=True),
               type_=postgresql.TIMESTAMP(),
               existing_nullable=True)
    op.alter_column('favorite_products', 'updated_at',
               existing_type=sa.DateTime(timezone=True),
               type_=postgresql.TIMESTAMP(),
               existing_nullable=False,
               existing_server_default=sa.text('now()'))
    op.alter_column('favorite_products', 'created_at',
               existing_type=sa.DateTime(timezone=True),
               type_=postgresql.TIMESTAMP(),
               existing_nullable=False,
               existing_server_default=sa.text('now()'))
    op.alter_column('favorite_products', 'sort_order',
               existing_type=sa.INTEGER(),
               nullable=False,
               existing_server_default=sa.text('0'))
    op.alter_column('favorite_products', 'auto_reorder',
               existing_type=sa.BOOLEAN(),
               nullable=False,
               existing_server_default=sa.text('false'))
    op.create_unique_constraint(op.f('uq_departments_business_name'), 'departments', ['business_id', 'name'], postgresql_nulls_not_distinct=False)
    op.create_index(op.f('ix_departments_business_id'), 'departments', ['business_id'], unique=False)
    op.alter_column('departments', 'updated_at',
               existing_type=sa.DateTime(timezone=True),
               type_=postgresql.TIMESTAMP(),
               existing_nullable=False,
               existing_server_default=sa.text('now()'))
    op.alter_column('departments', 'created_at',
               existing_type=sa.DateTime(timezone=True),
               type_=postgresql.TIMESTAMP(),
               existing_nullable=False,
               existing_server_default=sa.text('now()'))
    op.drop_column('departments', 'deleted_at')
    op.create_index(op.f('ix_business_users_department_id'), 'business_users', ['department_id'], unique=False)
    op.create_table('stock_reservations',
    sa.Column('id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), autoincrement=False, nullable=False),
    sa.Column('layby_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('product_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('location_id', sa.UUID(), autoincrement=False, nullable=True),
    sa.Column('quantity', sa.INTEGER(), autoincrement=False, nullable=False),
    sa.Column('status', sa.VARCHAR(length=20), server_default=sa.text("'reserved'::character varying"), autoincrement=False, nullable=False),
    sa.Column('reserved_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.Column('released_at', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=True),
    sa.ForeignKeyConstraint(['layby_id'], ['laybys.id'], name=op.f('stock_reservations_layby_id_fkey'), ondelete='CASCADE'),
    sa.ForeignKeyConstraint(['product_id'], ['products.id'], name=op.f('stock_reservations_product_id_fkey'), ondelete='RESTRICT'),
    sa.PrimaryKeyConstraint('id', name=op.f('stock_reservations_pkey')),
    sa.UniqueConstraint('layby_id', 'product_id', 'location_id', name=op.f('uq_stock_reservation_layby_product_location'), postgresql_include=[], postgresql_nulls_not_distinct=False)
    )
    op.create_index(op.f('idx_stock_reservations_status'), 'stock_reservations', ['status'], unique=False)
    op.create_index(op.f('idx_stock_reservations_product'), 'stock_reservations', ['product_id'], unique=False)
    op.create_index(op.f('idx_stock_reservations_location'), 'stock_reservations', ['location_id'], unique=False)
    op.create_index(op.f('idx_stock_reservations_layby'), 'stock_reservations', ['layby_id'], unique=False)
    # ### end Alembic commands ###
